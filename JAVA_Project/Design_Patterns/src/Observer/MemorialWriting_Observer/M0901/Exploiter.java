package Observer.MemorialWriting_Observer.M0901;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;

public class Exploiter implements MySubject {
    private String name, content;
    private ConcurrentMap<String, MyObserver> observers = new ConcurrentHashMap<>();

    public Exploiter(String name) {
        this.name = name;
    }

    @Override
    public void registerObserver(MyObserver observer) {
        this.observers.put(observer.getName(), observer);
    }

    @Override
    public void removeObserver(MyObserver observer) {
        this.observers.remove(observer.getName());
    }

    @Override
    public void notifyObserver() {
        try {
            long beginTime = System.currentTimeMillis();
            CountDownLatch latch = new CountDownLatch(observers.size());
            for (MyObserver observer : observers.values()) {
                MessageSend messageSend = new MessageSend(observer, content, latch);
                messageSend.start();
            }
            latch.await();
            long endTime = System.currentTimeMillis();
            System.out.println(this.name + "，已向所有租客通知消息！耗时：" + (endTime - beginTime) + "ms");
            System.out.println();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void postMessage(String content) {
        if (content != null && !content.trim().equals("")) {
            this.content = content;
            System.out.println(this.name + "发布消息了！内容是：" + content);
            this.notifyObserver();
        }
    }

}
