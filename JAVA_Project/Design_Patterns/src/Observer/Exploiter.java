package Observer;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;

/**
 * 房东
 */
public class Exploiter implements MySubject {
    private String name;
    private ConcurrentMap<String, MyObserver> observers;
    private String content;

    public Exploiter(String name) {
        this.name = name;
        observers = new ConcurrentHashMap<>();
        content = "";
    }

    @Override
    public void registerObserver(MyObserver observer) {
        this.observers.put(observer.getName(), observer);
    }

    @Override
    public void removeObserver(MyObserver observer) {
        observers.remove(observer.getName());
    }

    /**
     * CountDownLatch就一个线程同步工具，它相当于一个倒时计数器，用来协调多个线程的执行。
     * 多个线程通过调用它们所共享的计数器CountDownLatch的countDown方法来让计数器减1。
     * 通过await方法来阻塞当前线程，直到计数器变成0。
     */

    @Override
    public void notifyObserver() {
        try {
            long beginTime = System.currentTimeMillis();
//            初始化state的值，state等于同步线程数
            CountDownLatch latch = new CountDownLatch(observers.size());
            int i = 1;
            for (MyObserver observer : observers.values()) {
                MessageSending messageSending = new MessageSending(latch, observer, content, i);
                messageSending.start();
                i++;
            }
//            让线程阻塞
            latch.await();
            long endTime = System.currentTimeMillis();
            System.out.println(name + "消息发送完毕，耗时：" + (endTime - beginTime));
            System.out.println();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * 房东要发信息啦
     */
    public void postMessage(String content) {
        if (content != null && !content.trim().equals("")) {
            this.content = content;
            System.out.println(name + "发布信息：" + content);
            this.notifyObserver();
        }
    }
}
